Semidefinite programming (SDP) is a subfield of mathematical programming concerned with the optimization of a linear objective function (a user-specified function that the user wants to minimize or maximize)
over the intersection of the cone of positive semidefinite matrices with an affine space, i.e., a spectrahedron.
Semidefinite programming is a relatively new field of optimization which is of growing interest for several reasons. Many practical problems in operations research and combinatorial optimization can be modeled or approximated as semidefinite programming problems. In automatic control theory, SDPs are used in the context of linear matrix inequalities.  SDPs are in fact a special case of cone programming and can be efficiently solved by interior point methods.
All linear programs and (convex) quadratic programs can be expressed as SDPs, and via hierarchies of SDPs the solutions of polynomial optimization problems can be approximated.  Semidefinite programming has been used in the optimization of complex systems. In recent years, some quantum query complexity problems have been formulated in terms of semidefinite programs.


== Motivation and definition ==


=== Initial motivation ===
A linear programming problem is one in which we wish to maximize or minimize a linear objective function of real variables over a polytope. In semidefinite programming, we instead use real-valued vectors and are allowed to take the dot product of vectors; nonnegativity constraints on real variables in LP (linear programming) are replaced by semidefiniteness constraints on matrix variables in SDP (semidefinite programming). Specifically, a general semidefinite programming problem can be defined as any mathematical programming problem of the form

  
    
      
        
          
            
              
                
                  
                    
                      min
                      
                        
                          x
                          
                            1
                          
                        
                        ,
                        …
                        ,
                        
                          x
                          
                            n
                          
                        
                        ∈
                        
                          
                            R
                          
                          
                            n
                          
                        
                      
                    
                  
                
              
              
                
                  
                    
                      ∑
                      
                        i
                        ,
                        j
                        ∈
                        [
                        n
                        ]
                      
                    
                    
                      c
                      
                        i
                        ,
                        j
                      
                    
                    (
                    
                      x
                      
                        i
                      
                    
                    ⋅
                    
                      x
                      
                        j
                      
                    
                    )
                  
                
              
            
            
              
                
                  subject to
                
              
              
                
                  
                    
                      ∑
                      
                        i
                        ,
                        j
                        ∈
                        [
                        n
                        ]
                      
                    
                    
                      a
                      
                        i
                        ,
                        j
                        ,
                        k
                      
                    
                    (
                    
                      x
                      
                        i
                      
                    
                    ⋅
                    
                      x
                      
                        j
                      
                    
                    )
                    ≤
                    
                      b
                      
                        k
                      
                    
                  
                
                
                   for all 
                
                k
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \min _{x^{1},\ldots ,x^{n}\in \mathbb {R} ^{n}}}&{\displaystyle \sum _{i,j\in [n]}c_{i,j}(x^{i}\cdot x^{j})}\\{\text{subject to}}&{\displaystyle \sum _{i,j\in [n]}a_{i,j,k}(x^{i}\cdot x^{j})\leq b_{k}}{\text{  for all }}k\\\end{array}}}
  

where the 
  
    
      
        
          c
          
            i
            ,
            j
          
        
        ,
        
          a
          
            i
            ,
            j
            ,
            k
          
        
      
    
    {\displaystyle c_{i,j},a_{i,j,k}}
  
, and the 
  
    
      
        
          b
          
            k
          
        
      
    
    {\displaystyle b_{k}}
  
 are real numbers and 
  
    
      
        
          x
          
            i
          
        
        ⋅
        
          x
          
            j
          
        
      
    
    {\displaystyle x^{i}\cdot x^{j}}
  
 is the dot product of 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x^{i}}
  
 and  
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x^{j}}
  
.


=== Equivalent formulations ===
An 
  
    
      
        n
        ×
        n
      
    
    {\displaystyle n\times n}
  
 matrix 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is said to be positive semidefinite if it is the Gram matrix of some vectors (i.e. if there exist vectors 
  
    
      
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            n
          
        
      
    
    {\displaystyle x^{1},\ldots ,x^{n}}
  
 such that 
  
    
      
        
          m
          
            i
            ,
            j
          
        
        =
        
          x
          
            i
          
        
        ⋅
        
          x
          
            j
          
        
      
    
    {\displaystyle m_{i,j}=x^{i}\cdot x^{j}}
  
 for all 
  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
  
). If this is the case, we denote this as 
  
    
      
        M
        ⪰
        0
      
    
    {\displaystyle M\succeq 0}
  
. Note that there are several other equivalent definitions of being positive semidefinite, for example, positive semidefinite matrices are self-adjoint matrices that have only non-negative eigenvalues.

Denote by 
  
    
      
        
          
            S
          
          
            n
          
        
      
    
    {\displaystyle \mathbb {S} ^{n}}
  
 the space of all 
  
    
      
        n
        ×
        n
      
    
    {\displaystyle n\times n}
  
 real symmetric matrices.  The space is equipped with the inner product (where 
  
    
      
        
          
            t
            r
            a
            c
            e
          
        
      
    
    {\displaystyle {\rm {trace}}}
  
 denotes the trace):
  
    
      
        ⟨
        A
        ,
        B
        ⟩
        :=
        
          
            t
            r
            a
            c
            e
          
        
        (
        
          A
          
            T
          
        
        B
        )
        =
        
          ∑
          
            i
            =
            1
            ,
            j
            =
            1
          
          
            n
          
        
        
          A
          
            i
            j
          
        
        
          B
          
            i
            j
          
        
        .
      
    
    {\displaystyle \langle A,B\rangle :={\rm {trace}}(A^{T}B)=\sum _{i=1,j=1}^{n}A_{ij}B_{ij}.}
  
We can rewrite the mathematical program given in the previous section equivalently as

  
    
      
        
          
            
              
                
                  
                    
                      min
                      
                        X
                        ∈
                        
                          
                            S
                          
                          
                            n
                          
                        
                      
                    
                  
                
              
              
                ⟨
                C
                ,
                X
                ⟩
              
            
            
              
                
                  subject to
                
              
              
                ⟨
                
                  A
                  
                    k
                  
                
                ,
                X
                ⟩
                ≤
                
                  b
                  
                    k
                  
                
                ,
                
                k
                =
                1
                ,
                …
                ,
                m
              
            
            
              
              
                X
                ⪰
                0.
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \min _{X\in \mathbb {S} ^{n}}}&\langle C,X\rangle \\{\text{subject to}}&\langle A_{k},X\rangle \leq b_{k},\quad k=1,\ldots ,m\\&X\succeq 0.\end{array}}}
  

where entry 
  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
  
 in 
  
    
      
        C
      
    
    {\displaystyle C}
  
 is given by 
  
    
      
        
          
            
              
                c
                
                  i
                  ,
                  j
                
              
              +
              
                c
                
                  j
                  ,
                  i
                
              
            
            2
          
        
      
    
    {\displaystyle {\frac {c_{i,j}+c_{j,i}}{2}}}
  
 from the previous section and 
  
    
      
        
          A
          
            k
          
        
      
    
    {\displaystyle A_{k}}
  
 is a symmetric 
  
    
      
        n
        ×
        n
      
    
    {\displaystyle n\times n}
  
 matrix having 
  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
  
th entry 
  
    
      
        
          
            
              
                a
                
                  i
                  ,
                  j
                  ,
                  k
                
              
              +
              
                a
                
                  j
                  ,
                  i
                  ,
                  k
                
              
            
            2
          
        
      
    
    {\displaystyle {\frac {a_{i,j,k}+a_{j,i,k}}{2}}}
  
 from the previous section. Thus, the matrices  
  
    
      
        C
      
    
    {\displaystyle C}
  
 and 
  
    
      
        
          A
          
            k
          
        
      
    
    {\displaystyle A_{k}}
  
 are symmetric and the above inner products are well-defined.
Note that if we add slack variables appropriately, this SDP can be converted to an equational form:

  
    
      
        
          
            
              
                
                  
                    
                      min
                      
                        X
                        ∈
                        
                          
                            S
                          
                          
                            n
                          
                        
                      
                    
                  
                
              
              
                ⟨
                C
                ,
                X
                ⟩
              
            
            
              
                
                  subject to
                
              
              
                ⟨
                
                  A
                  
                    k
                  
                
                ,
                X
                ⟩
                =
                
                  b
                  
                    k
                  
                
                ,
                
                k
                =
                1
                ,
                …
                ,
                m
              
            
            
              
              
                X
                ⪰
                0.
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \min _{X\in \mathbb {S} ^{n}}}&\langle C,X\rangle \\{\text{subject to}}&\langle A_{k},X\rangle =b_{k},\quad k=1,\ldots ,m\\&X\succeq 0.\end{array}}}
  

For convenience, an SDP may be specified in a slightly different, but equivalent form.  For example, linear expressions involving nonnegative scalar variables may be added to the program specification.  This remains an SDP because each variable can be incorporated into the matrix 
  
    
      
        X
      
    
    {\displaystyle X}
  
 as a diagonal entry (
  
    
      
        
          X
          
            i
            i
          
        
      
    
    {\displaystyle X_{ii}}
  
 for some 
  
    
      
        i
      
    
    {\displaystyle i}
  
).  To ensure that 
  
    
      
        
          X
          
            i
            i
          
        
        ≥
        0
      
    
    {\displaystyle X_{ii}\geq 0}
  
, constraints 
  
    
      
        
          X
          
            i
            j
          
        
        =
        0
      
    
    {\displaystyle X_{ij}=0}
  
 can be added for all 
  
    
      
        j
        ≠
        i
      
    
    {\displaystyle j\neq i}
  
.  As another example, note that for any positive semidefinite matrix 
  
    
      
        X
      
    
    {\displaystyle X}
  
, there exists a set of vectors 
  
    
      
        {
        
          v
          
            i
          
        
        }
      
    
    {\displaystyle \{v_{i}\}}
  
 such that the 
  
    
      
        i
      
    
    {\displaystyle i}
  
, 
  
    
      
        j
      
    
    {\displaystyle j}
  
 entry of 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is 
  
    
      
        
          X
          
            i
            j
          
        
        =
        (
        
          v
          
            i
          
        
        ,
        
          v
          
            j
          
        
        )
      
    
    {\displaystyle X_{ij}=(v_{i},v_{j})}
  
 the scalar product of 
  
    
      
        
          v
          
            i
          
        
      
    
    {\displaystyle v_{i}}
  
 and 
  
    
      
        
          v
          
            j
          
        
      
    
    {\displaystyle v_{j}}
  
.  Therefore, SDPs are often formulated in terms of linear expressions on scalar products of vectors.  Given the solution to the SDP in the standard form, the vectors 
  
    
      
        {
        
          v
          
            i
          
        
        }
      
    
    {\displaystyle \{v_{i}\}}
  
 can be recovered in 
  
    
      
        O
        (
        
          n
          
            3
          
        
        )
      
    
    {\displaystyle O(n^{3})}
  
 time (e.g., by using an incomplete Cholesky decomposition of X).


== Relations to other optimization problems ==
The space of semidefinite matrices is a convex cone. Therefore, SDP is a special case of conic optimization, which is a special case of convex optimization.
When the matrix C is diagonal, the inner products <C,X> is equivalent to a vector product of the diagonal of C and the diagonal of X. Analogously, when the matrices Ak are diagonal, the corresponding inner products are equivalent to vector products. In these vector products, only the diagonal elements of X are used, so we can add constraints equating the non-diagonal elements of X to 0. The condition 
  
    
      
        X
        ⪰
        0
      
    
    {\displaystyle X\succeq 0}
  
 is then equivalent to the condition that all diagonal elements of X are non-negative. Then, the resulting SDP becomes a linear program in which the variables are the diagonal elements of X.


== Duality theory ==


=== Definitions ===
Analogously to linear programming, given a general SDP of the form

  
    
      
        
          
            
              
                
                  
                    
                      min
                      
                        X
                        ∈
                        
                          
                            S
                          
                          
                            n
                          
                        
                      
                    
                  
                
              
              
                ⟨
                C
                ,
                X
                ⟩
              
            
            
              
                
                  subject to
                
              
              
                ⟨
                
                  A
                  
                    i
                  
                
                ,
                X
                ⟩
                =
                
                  b
                  
                    i
                  
                
                ,
                
                i
                =
                1
                ,
                …
                ,
                m
              
            
            
              
              
                X
                ⪰
                0
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \min _{X\in \mathbb {S} ^{n}}}&\langle C,X\rangle \\{\text{subject to}}&\langle A_{i},X\rangle =b_{i},\quad i=1,\ldots ,m\\&X\succeq 0\end{array}}}
  

(the primal problem or P-SDP), we define the dual semidefinite program (D-SDP) as

  
    
      
        
          
            
              
                
                  
                    
                      max
                      
                        y
                        ∈
                        
                          
                            R
                          
                          
                            m
                          
                        
                      
                    
                  
                
              
              
                
                  b
                  
                    T
                  
                
                y
              
            
            
              
                
                  subject to
                
              
              
                
                  
                    
                      ∑
                      
                        i
                        =
                        1
                      
                      
                        m
                      
                    
                  
                
                
                  y
                  
                    i
                  
                
                
                  A
                  
                    i
                  
                
                ⪯
                C
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \max _{y\in \mathbb {R} ^{m}}}&b^{T}y\\{\text{subject to}}&{\displaystyle \sum _{i=1}^{m}}y_{i}A_{i}\preceq C\end{array}}}
  

where for any two matrices 
  
    
      
        P
      
    
    {\displaystyle P}
  
 and 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
, 
  
    
      
        P
        ⪰
        Q
      
    
    {\displaystyle P\succeq Q}
  
 means 
  
    
      
        P
        −
        Q
        ⪰
        0
      
    
    {\displaystyle P-Q\succeq 0}
  
.


=== Weak duality ===
The weak duality theorem states that the value of the primal SDP is at least the value of the dual SDP.  Therefore, any feasible solution to the dual SDP lower-bounds the primal SDP value, and conversely, any feasible solution to the primal SDP upper-bounds the dual SDP value.  This is because

  
    
      
        ⟨
        C
        ,
        X
        ⟩
        −
        
          b
          
            T
          
        
        y
        =
        ⟨
        C
        ,
        X
        ⟩
        −
        
          ∑
          
            i
            =
            1
          
          
            m
          
        
        
          y
          
            i
          
        
        
          b
          
            i
          
        
        =
        ⟨
        C
        ,
        X
        ⟩
        −
        
          ∑
          
            i
            =
            1
          
          
            m
          
        
        
          y
          
            i
          
        
        ⟨
        
          A
          
            i
          
        
        ,
        X
        ⟩
        =
        ⟨
        C
        −
        
          ∑
          
            i
            =
            1
          
          
            m
          
        
        
          y
          
            i
          
        
        
          A
          
            i
          
        
        ,
        X
        ⟩
        ≥
        0
        ,
      
    
    {\displaystyle \langle C,X\rangle -b^{T}y=\langle C,X\rangle -\sum _{i=1}^{m}y_{i}b_{i}=\langle C,X\rangle -\sum _{i=1}^{m}y_{i}\langle A_{i},X\rangle =\langle C-\sum _{i=1}^{m}y_{i}A_{i},X\rangle \geq 0,}
  

where the last inequality is because both matrices are positive semidefinite, and the result of this function is sometimes referred to as duality gap.


=== Strong duality ===
When the value of the primal and dual SDPs are equal, the SDP is said to satisfy the strong duality property. Unlike linear programs, where every dual linear program has optimal objective equal to the primal objective, not every SDP satisfies strong duality; in general, the value of the dual SDP may lie strictly below the value of the primal, and the P-SDP and D-SDP satisfy the following properties:
(i) Suppose the primal problem (P-SDP) is bounded below and strictly
feasible (i.e., there exists

  
    
      
        
          X
          
            0
          
        
        ∈
        
          
            S
          
          
            n
          
        
        ,
        
          X
          
            0
          
        
        ≻
        0
      
    
    {\displaystyle X_{0}\in \mathbb {S} ^{n},X_{0}\succ 0}
  
 such that 
  
    
      
        ⟨
        
          A
          
            i
          
        
        ,
        
          X
          
            0
          
        
        ⟩
        =
        
          b
          
            i
          
        
      
    
    {\displaystyle \langle A_{i},X_{0}\rangle =b_{i}}
  
, 
  
    
      
        i
        =
        1
        ,
        …
        ,
        m
      
    
    {\displaystyle i=1,\ldots ,m}
  
). Then there is an optimal solution 
  
    
      
        
          y
          
            ∗
          
        
      
    
    {\displaystyle y^{*}}
  
 to (D-SDP) and

  
    
      
        ⟨
        C
        ,
        
          X
          
            ∗
          
        
        ⟩
        =
        
          b
          
            T
          
        
        
          y
          
            ∗
          
        
        .
      
    
    {\displaystyle \langle C,X^{*}\rangle =b^{T}y^{*}.}
  

(ii) Suppose the dual problem (D-SDP) is bounded above and strictly
feasible (i.e.,

  
    
      
        
          ∑
          
            i
            =
            1
          
          
            m
          
        
        (
        
          y
          
            0
          
        
        
          )
          
            i
          
        
        
          A
          
            i
          
        
        ≺
        C
      
    
    {\displaystyle \sum _{i=1}^{m}(y_{0})_{i}A_{i}\prec C}
  
 for some 
  
    
      
        
          y
          
            0
          
        
        ∈
        
          
            R
          
          
            m
          
        
      
    
    {\displaystyle y_{0}\in \mathbb {R} ^{m}}
  
).
Then there is an optimal solution 
  
    
      
        
          X
          
            ∗
          
        
      
    
    {\displaystyle X^{*}}
  
 to (P-SDP) and
the equality from (i) holds.
A sufficient condition for strong duality to hold for a SDP problem (and in general, for any convex optimization problem) is the Slater's condition. It is also possible to attain strong duality for SDPs without additional regularity conditions by using an extended dual problem proposed by Ramana.


== Examples ==


=== Example 1 ===
Consider three random variables 
  
    
      
        A
      
    
    {\displaystyle A}
  
, 
  
    
      
        B
      
    
    {\displaystyle B}
  
, and 
  
    
      
        C
      
    
    {\displaystyle C}
  
.  A given set of correlation coefficients 
  
    
      
        
          ρ
          
            A
            B
          
        
        ,
         
        
          ρ
          
            A
            C
          
        
        ,
        
          ρ
          
            B
            C
          
        
      
    
    {\displaystyle \rho _{AB},\ \rho _{AC},\rho _{BC}}
  
 are possible if and only if

  
    
      
        
          
            (
            
              
                
                  1
                
                
                  
                    ρ
                    
                      A
                      B
                    
                  
                
                
                  
                    ρ
                    
                      A
                      C
                    
                  
                
              
              
                
                  
                    ρ
                    
                      A
                      B
                    
                  
                
                
                  1
                
                
                  
                    ρ
                    
                      B
                      C
                    
                  
                
              
              
                
                  
                    ρ
                    
                      A
                      C
                    
                  
                
                
                  
                    ρ
                    
                      B
                      C
                    
                  
                
                
                  1
                
              
            
            )
          
        
        ⪰
        0.
      
    
    {\displaystyle {\begin{pmatrix}1&\rho _{AB}&\rho _{AC}\\\rho _{AB}&1&\rho _{BC}\\\rho _{AC}&\rho _{BC}&1\end{pmatrix}}\succeq 0.}
  

This matrix is called the correlation matrix. Suppose that we know from some prior knowledge (empirical results of an experiment, for example) that 
  
    
      
        −
        0.2
        ≤
        
          ρ
          
            A
            B
          
        
        ≤
        −
        0.1
      
    
    {\displaystyle -0.2\leq \rho _{AB}\leq -0.1}
  
 and 
  
    
      
        0.4
        ≤
        
          ρ
          
            B
            C
          
        
        ≤
        0.5
      
    
    {\displaystyle 0.4\leq \rho _{BC}\leq 0.5}
  
.  The problem of determining the smallest and largest values that 
  
    
      
        
          ρ
          
            A
            C
          
        
         
      
    
    {\displaystyle \rho _{AC}\ }
  
 can take is given by:

  
    
      
        
          
            
              
                
                  
                    min
                    
                      /
                    
                    max
                  
                
              
              
                
                  x
                  
                    13
                  
                
              
            
            
              
                
                  subject to
                
              
              
                −
                0.2
                ≤
                
                  x
                  
                    12
                  
                
                ≤
                −
                0.1
              
            
            
              
              
                0.4
                ≤
                
                  x
                  
                    23
                  
                
                ≤
                0.5
              
            
            
              
              
                
                  
                    (
                    
                      
                        
                          1
                        
                        
                          
                            x
                            
                              12
                            
                          
                        
                        
                          
                            x
                            
                              13
                            
                          
                        
                      
                      
                        
                          
                            x
                            
                              12
                            
                          
                        
                        
                          1
                        
                        
                          
                            x
                            
                              23
                            
                          
                        
                      
                      
                        
                          
                            x
                            
                              13
                            
                          
                        
                        
                          
                            x
                            
                              23
                            
                          
                        
                        
                          1
                        
                      
                    
                    )
                  
                
                ⪰
                0
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \min /\max }&x_{13}\\{\text{subject to}}&-0.2\leq x_{12}\leq -0.1\\&0.4\leq x_{23}\leq 0.5\\&{\begin{pmatrix}1&x_{12}&x_{13}\\x_{12}&1&x_{23}\\x_{13}&x_{23}&1\end{pmatrix}}\succeq 0\end{array}}}
  

We set 
  
    
      
        
          ρ
          
            A
            B
          
        
        =
        
          x
          
            12
          
        
        ,
         
        
          ρ
          
            A
            C
          
        
        =
        
          x
          
            13
          
        
        ,
         
        
          ρ
          
            B
            C
          
        
        =
        
          x
          
            23
          
        
      
    
    {\displaystyle \rho _{AB}=x_{12},\ \rho _{AC}=x_{13},\ \rho _{BC}=x_{23}}
  
 to obtain the answer.  This can be formulated by an SDP.  We handle the inequality constraints by augmenting the variable matrix and introducing slack variables, for example

  
    
      
        
          t
          r
        
        
          (
          
            
              (
              
                
                  
                    
                      0
                    
                    
                      1
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      1
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                
              
              )
            
            ⋅
            
              (
              
                
                  
                    
                      1
                    
                    
                      
                        x
                        
                          12
                        
                      
                    
                    
                      
                        x
                        
                          13
                        
                      
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      
                        x
                        
                          12
                        
                      
                    
                    
                      1
                    
                    
                      
                        x
                        
                          23
                        
                      
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      
                        x
                        
                          13
                        
                      
                    
                    
                      
                        x
                        
                          23
                        
                      
                    
                    
                      1
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      
                        s
                        
                          1
                        
                      
                    
                    
                      0
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      
                        s
                        
                          2
                        
                      
                    
                    
                      0
                    
                  
                  
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      0
                    
                    
                      
                        s
                        
                          3
                        
                      
                    
                  
                
              
              )
            
          
          )
        
        =
        
          x
          
            12
          
        
        +
        
          s
          
            1
          
        
        =
        −
        0.1
      
    
    {\displaystyle \mathrm {tr} \left(\left({\begin{array}{cccccc}0&1&0&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\\0&0&0&1&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\end{array}}\right)\cdot \left({\begin{array}{cccccc}1&x_{12}&x_{13}&0&0&0\\x_{12}&1&x_{23}&0&0&0\\x_{13}&x_{23}&1&0&0&0\\0&0&0&s_{1}&0&0\\0&0&0&0&s_{2}&0\\0&0&0&0&0&s_{3}\end{array}}\right)\right)=x_{12}+s_{1}=-0.1}
  

Solving this SDP gives the minimum and maximum values of 
  
    
      
        
          ρ
          
            A
            C
          
        
        =
        
          x
          
            13
          
        
         
      
    
    {\displaystyle \rho _{AC}=x_{13}\ }
  
 as 
  
    
      
        −
        0.978
      
    
    {\displaystyle -0.978}
  
 and 
  
    
      
        0.872
      
    
    {\displaystyle 0.872}
  
 respectively.


=== Example 2 ===
Consider the problem

minimize 
  
    
      
        
          
            
              (
              
                c
                
                  T
                
              
              x
              
                )
                
                  2
                
              
            
            
              
                d
                
                  T
                
              
              x
            
          
        
      
    
    {\displaystyle {\frac {(c^{T}x)^{2}}{d^{T}x}}}
  

subject to 
  
    
      
        A
        x
        +
        b
        ≥
        0
      
    
    {\displaystyle Ax+b\geq 0}
  

where we assume that 
  
    
      
        
          d
          
            T
          
        
        x
        >
        0
      
    
    {\displaystyle d^{T}x>0}
  
 whenever 
  
    
      
        A
        x
        +
        b
        ≥
        0
      
    
    {\displaystyle Ax+b\geq 0}
  
.
Introducing an auxiliary variable 
  
    
      
        t
      
    
    {\displaystyle t}
  
 the problem can be reformulated:

minimize 
  
    
      
        t
      
    
    {\displaystyle t}
  

subject to 
  
    
      
        A
        x
        +
        b
        ≥
        0
        ,
        
        
          
            
              (
              
                c
                
                  T
                
              
              x
              
                )
                
                  2
                
              
            
            
              
                d
                
                  T
                
              
              x
            
          
        
        ≤
        t
      
    
    {\displaystyle Ax+b\geq 0,\,{\frac {(c^{T}x)^{2}}{d^{T}x}}\leq t}
  

In this formulation, the objective is a linear function of the variables 
  
    
      
        x
        ,
        t
      
    
    {\displaystyle x,t}
  
.
The first restriction can be written as

  
    
      
        
          
            diag
          
        
        (
        A
        x
        +
        b
        )
        ≥
        0
      
    
    {\displaystyle {\textbf {diag}}(Ax+b)\geq 0}
  

where the matrix 
  
    
      
        
          
            diag
          
        
        (
        A
        x
        +
        b
        )
      
    
    {\displaystyle {\textbf {diag}}(Ax+b)}
  
 is the square matrix with values in the diagonal equal
to the elements of the vector 
  
    
      
        A
        x
        +
        b
      
    
    {\displaystyle Ax+b}
  
.
The second restriction can be written as

  
    
      
        t
        
          d
          
            T
          
        
        x
        −
        (
        
          c
          
            T
          
        
        x
        
          )
          
            2
          
        
        ≥
        0
      
    
    {\displaystyle td^{T}x-(c^{T}x)^{2}\geq 0}
  

Defining 
  
    
      
        D
      
    
    {\displaystyle D}
  
 as follows

  
    
      
        D
        =
        
          [
          
            
              
                
                  t
                
                
                  
                    c
                    
                      T
                    
                  
                  x
                
              
              
                
                  
                    c
                    
                      T
                    
                  
                  x
                
                
                  
                    d
                    
                      T
                    
                  
                  x
                
              
            
          
          ]
        
      
    
    {\displaystyle D=\left[{\begin{array}{cc}t&c^{T}x\\c^{T}x&d^{T}x\end{array}}\right]}
  

We can use the theory of Schur Complements to see that

  
    
      
        D
        ⪰
        0
      
    
    {\displaystyle D\succeq 0}
  

(Boyd and Vandenberghe, 1996)
The semidefinite program associated with this problem is

minimize 
  
    
      
        t
      
    
    {\displaystyle t}
  

subject to 
  
    
      
        
          [
          
            
              
                
                  
                    
                      diag
                    
                  
                  (
                  A
                  x
                  +
                  b
                  )
                
                
                  0
                
                
                  0
                
              
              
                
                  0
                
                
                  t
                
                
                  
                    c
                    
                      T
                    
                  
                  x
                
              
              
                
                  0
                
                
                  
                    c
                    
                      T
                    
                  
                  x
                
                
                  
                    d
                    
                      T
                    
                  
                  x
                
              
            
          
          ]
        
        ⪰
        0
      
    
    {\displaystyle \left[{\begin{array}{ccc}{\textbf {diag}}(Ax+b)&0&0\\0&t&c^{T}x\\0&c^{T}x&d^{T}x\end{array}}\right]\succeq 0}
  


=== Example 3 (Goemans–Williamson max cut approximation algorithm) ===
Semidefinite programs are important tools for developing approximation algorithms for NP-hard maximization problems.  The first approximation algorithm based on an SDP is due to Michel Goemans and David P. Williamson (JACM, 1995).: Chap.1   They studied the max cut problem: Given a graph G = (V, E), output a partition of the vertices V so as to maximize the number of edges crossing from one side to the other.  This problem can be expressed as an integer quadratic program:

Maximize 
  
    
      
        
          ∑
          
            (
            i
            ,
            j
            )
            ∈
            E
          
        
        
          
            
              1
              −
              
                v
                
                  i
                
              
              
                v
                
                  j
                
              
            
            2
          
        
        ,
      
    
    {\displaystyle \sum _{(i,j)\in E}{\frac {1-v_{i}v_{j}}{2}},}
  
 such that each 
  
    
      
        
          v
          
            i
          
        
        ∈
        {
        1
        ,
        −
        1
        }
      
    
    {\displaystyle v_{i}\in \{1,-1\}}
  
.
Unless P = NP, we cannot solve this maximization problem efficiently.  However, Goemans and Williamson observed a general three-step procedure for attacking this sort of problem:

Relax the integer quadratic program into an SDP.
Solve the SDP (to within an arbitrarily small additive error 
  
    
      
        ϵ
      
    
    {\displaystyle \epsilon }
  
).
Round the SDP solution to obtain an approximate solution to the original integer quadratic program.
For max cut, the most natural relaxation is

  
    
      
        max
        
          ∑
          
            (
            i
            ,
            j
            )
            ∈
            E
          
        
        
          
            
              1
              −
              ⟨
              
                v
                
                  i
                
              
              ,
              
                v
                
                  j
                
              
              ⟩
            
            2
          
        
        ,
      
    
    {\displaystyle \max \sum _{(i,j)\in E}{\frac {1-\langle v_{i},v_{j}\rangle }{2}},}
  
 such that 
  
    
      
        ‖
        
          v
          
            i
          
        
        
          ‖
          
            2
          
        
        =
        1
      
    
    {\displaystyle \lVert v_{i}\rVert ^{2}=1}
  
, where the maximization is over vectors 
  
    
      
        {
        
          v
          
            i
          
        
        }
      
    
    {\displaystyle \{v_{i}\}}
  
 instead of integer scalars.
This is an SDP because the objective function and constraints are all linear functions of vector inner products.  Solving the SDP gives a set of unit vectors in 
  
    
      
        
          
            R
            
              n
            
          
        
      
    
    {\displaystyle \mathbf {R^{n}} }
  
; since the vectors are not required to be collinear, the value of this relaxed program can only be higher than the value of the original quadratic integer program.  Finally, a rounding procedure is needed to obtain a partition.  Goemans and Williamson simply choose a uniformly random hyperplane through the origin and divide the vertices according to which side of the hyperplane the corresponding vectors lie.  Straightforward analysis shows that this procedure achieves an expected approximation ratio (performance guarantee) of 0.87856 - ε.  (The expected value of the cut is the sum over edges of the probability that the edge is cut, which is proportional to the angle 
  
    
      
        
          cos
          
            −
            1
          
        
        ⁡
        ⟨
        
          v
          
            i
          
        
        ,
        
          v
          
            j
          
        
        ⟩
      
    
    {\displaystyle \cos ^{-1}\langle v_{i},v_{j}\rangle }
  
 between the vectors at the endpoints of the edge over 
  
    
      
        π
      
    
    {\displaystyle \pi }
  
.  Comparing this probability to 
  
    
      
        (
        1
        −
        ⟨
        
          v
          
            i
          
        
        ,
        
          v
          
            j
          
        
        ⟩
        )
        
          /
        
        
          2
        
      
    
    {\displaystyle (1-\langle v_{i},v_{j}\rangle )/{2}}
  
, in expectation the ratio is always at least 0.87856.)  Assuming the unique games conjecture, it can be shown that this approximation ratio is essentially optimal.
Since the original paper of Goemans and Williamson, SDPs have been applied to develop numerous approximation algorithms. Subsequently, Prasad Raghavendra has developed a general framework for constraint satisfaction problems based on the unique games conjecture.


=== Other applications ===
Semidefinite programming has been applied to find approximate solutions to combinatorial optimization problems, such as the solution of the max cut problem with an approximation ratio of 0.87856.  SDPs are also used in geometry to determine tensegrity graphs, and arise in control theory as LMIs, and in inverse elliptic coefficient problems as convex, non-linear, semidefiniteness constraints. It is also widely used in physics to constrain conformal field theories with the conformal bootstrap.


== Run-time complexity ==
The semidefinite feasibility problem (SDF) is the following decision problem: given an SDP, decide whether it has at least one feasible solution. The exact run-time complexity of this problem is unknown (as of 1997). However, Ramana proved the following:

In the Turing machine model, SDF is in NP iff it is in co-NP. Therefore, SDF is not NP-complete unless NP=coNP.
In the Blum–Shub–Smale machine model, SDF is in the intersection of NP and co-NP.


== Algorithms for solving SDPs ==
There are several types of algorithms for solving SDPs. These algorithms output the value of the SDP up to an additive error 
  
    
      
        ϵ
      
    
    {\displaystyle \epsilon }
  
 in time that is polynomial in the program description size and 
  
    
      
        log
        ⁡
        (
        1
        
          /
        
        ϵ
        )
      
    
    {\displaystyle \log(1/\epsilon )}
  
.


=== Ellipsoid method ===
The ellipsoid method is a general method for convex programming, and can be used in particular to solve SDPs. In the context of SDPs, the ellipsoid method provides the following guarantee.: Thm.2.6.1 Consider an SDP in the following equational form:
  
    
      
        
          
            
              
                
                  
                    
                      max
                      
                        X
                        ∈
                        
                          
                            S
                          
                          
                            n
                          
                        
                      
                    
                  
                
              
              
                ⟨
                C
                ,
                X
                ⟩
              
            
            
              
                
                  subject to
                
              
              
                ⟨
                
                  A
                  
                    k
                  
                
                ,
                X
                ⟩
                =
                
                  b
                  
                    k
                  
                
                ,
                
                k
                =
                1
                ,
                …
                ,
                m
              
            
            
              
              
                X
                ⪰
                0.
              
            
          
        
      
    
    {\displaystyle {\begin{array}{rl}{\displaystyle \max _{X\in \mathbb {S} ^{n}}}&\langle C,X\rangle \\{\text{subject to}}&\langle A_{k},X\rangle =b_{k},\quad k=1,\ldots ,m\\&X\succeq 0.\end{array}}}
  
Let L be the affine subspace of matrices in Sn satisfying the m equational constraints; so the SDP can be written as: 
  
    
      
        
          max
          
            X
            ∈
            L
          
        
        ⟨
        C
        ,
        X
        ⟩
        
           subject to 
        
        X
        ⪰
        0
      
    
    {\displaystyle \max _{X\in L}\langle C,X\rangle {\text{ subject to }}X\succeq 0}
  
. Suppose all coefficients in the SDP are rational numbers.  Let R be an explicitly given upper bound on the maximum Frobenius norm of a feasible solution, and ε>0 a constant. A matrix X in Sn is called ε-deep if every matrix Y in L with Frobenius distance at most ε from X satisfies the feasibility condition 
  
    
      
        Y
        ⪰
        0
      
    
    {\displaystyle Y\succeq 0}
  
. Denote 
  
    
      
        
          v
          
            d
            e
            e
            p
          
        
        :=
        sup
        {
        ⟨
        C
        ,
        X
        ⟩
        :
        X
        
           is 
        
        ϵ
        
          -deep
        
        }
      
    
    {\displaystyle v_{deep}:=\sup\{\langle C,X\rangle :X{\text{ is }}\epsilon {\text{-deep}}\}}
  
. The ellipsoid returns one of the following outputs:
A matrix X* in L (that is, satisfying all linear equality constraints exactly), such that the Frobenius distance between X* and some feasible solution is at most ε (that is, approximately satisfying the inequality constraint 
  
    
      
        X
        ⪰
        0
      
    
    {\displaystyle X\succeq 0}
  
), and 
  
    
      
        ⟨
        C
        ,
        
          X
          
            ∗
          
        
        ⟩
        ≥
        
          v
          
            d
            e
            e
            p
          
        
        −
        ϵ
      
    
    {\displaystyle \langle C,X^{*}\rangle \geq v_{deep}-\epsilon }
  
 (that is, approximately optimal objective value).
A certificate that the problem has no ε-deep solutions (that is, the problem is approximately infeasible).
The run-time is polynomial in the binary encodings of the inputs and in log(R/ε), in the Turing machine model.
Note that, in general, R may be doubly-exponential in n. In that case, the run-time guarantee of the ellipsoid method is exponential in n. But in most applications, R is not so huge. In these cases, the ellipsoid method is the only known method that guarantees polynomial runtime in the Turing machine model.: 23  But in practice, its performance is not so good.


=== Interior point methods ===
Most codes are based on interior point methods (CSDP, MOSEK, SeDuMi, SDPT3, DSDP, SDPA). These are robust and efficient for general linear SDP problems, but restricted by the fact that the algorithms are second-order methods and need to store and factorize a large (and often dense) matrix. Theoretically, the state-of-the-art high-accuracy SDP algorithms are based on this approach.


=== First-order methods ===
First-order methods for conic optimization avoid computing, storing and factorizing a large Hessian matrix and scale to much larger problems than interior point methods, at some cost in accuracy. A first-order method is implemented in the Splitting Cone Solver (SCS). Another first-order method is the alternating direction method of multipliers (ADMM). This method requires in every step projection on the cone of semidefinite matrices.


=== Bundle method ===
The code ConicBundle formulates the SDP problem as a nonsmooth optimization problem and solves it by the Spectral Bundle method of nonsmooth optimization. This approach is very efficient for a special class of linear SDP problems.


=== Other solving methods ===
Algorithms based on Augmented Lagrangian method (PENSDP) are similar in behavior to the interior point methods and can be specialized to some very large scale problems. Other algorithms use low-rank information and reformulation of the SDP as a nonlinear programming problem (SDPLR, ManiSDP).


=== Approximate methods ===
Algorithms that solve SDPs approximately have been proposed as well. The main goal of such methods is to achieve lower complexity in applications where approximate solutions are sufficient and complexity must be minimal. A prominent method that has been used for data detection in multiple-input multiple-output (MIMO) wireless systems is Triangular Approximate SEmidefinite Relaxation (TASER), which operates on the Cholesky decomposition factors of the semidefinite matrix instead of the semidefinite matrix. This method calculates approximate solutions for a max-cut-like problem that are often comparable to solutions from exact solvers but in only 10-20 algorithm iterations. Hazan has developed an approximate algorithm for solving SDPs with the additional constraint that the trace of the variables matrix must be 1.


== Preprocessing algorithms ==
Facial reduction algorithms are algorithms used to preprocess SDPs problems by inspecting the constraints of the problem. These can be used to

Detect lack of strict feasibility;
Delete redundant rows and columns;
Reduce the size of the variable matrix.


== See also ==
Square-root sum problem - a special case of an SDP feasibility problem.


== References ==

Lieven Vandenberghe, Stephen Boyd, "Semidefinite Programming", SIAM Review 38, March 1996, pp. 49–95. pdf
Monique Laurent, Franz Rendl, "Semidefinite Programming and Integer Programming", Report PNA-R0210, CWI, Amsterdam, April 2002. optimization-online
E. de Klerk, "Aspects of Semidefinite Programming: Interior Point Algorithms and Selected Applications", Kluwer Academic Publishers, March 2002, ISBN 1-4020-0547-4.
Robert M. Freund, "Introduction to Semidefinite Programming (SDP), SDP-Introduction


== External links ==
Links to introductions and events in the field
Lecture notes from László Lovász on Semidefinite Programming